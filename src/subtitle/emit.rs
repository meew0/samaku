use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Error, Write};

use crate::nde::tags::{Colour, Transparency};
use crate::{nde, version};

use super::{
    Attachment, AttachmentType, EventType, Extradata, ExtradataEntry, ScriptInfo, SideData, Sline,
    SlineTrack, Style, YCbCrMatrix,
};

const NEWLINE: &str = "\n";
const STYLE_FORMAT: &str = "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding";
const EVENT_FORMAT: &str =
    "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text";

/// Write the given ASS file data as an .ass file to the given writer.
///
/// # Errors
/// Errors when the writer cannot be written to, or when there is an unexpected format error.
pub fn emit<W: Write>(
    writer: &mut W,
    script_info: &ScriptInfo,
    subtitles: &SlineTrack,
    side_data: &SideData,
) -> Result<(), Error> {
    emit_script_info(writer, script_info)?;
    emit_aegi_metadata(writer, &side_data.aegi_metadata)?;
    emit_styles(writer, &subtitles.styles)?;
    emit_attachments(
        writer,
        "Graphics",
        "filename",
        &side_data.attachments,
        AttachmentType::Graphic,
    )?;
    emit_attachments(
        writer,
        "Fonts",
        "fontname",
        &side_data.attachments,
        AttachmentType::Font,
    )?;
    emit_events(writer, &subtitles.slines, &subtitles.styles)?;
    emit_extradata(writer, &subtitles.extradata)?;

    Ok(())
}

fn emit_script_info<W: Write>(writer: &mut W, script_info: &ScriptInfo) -> Result<(), Error> {
    write!(writer, "[Script Info]{NEWLINE}")?;
    write!(
        writer,
        "; Script generated by samaku {}{NEWLINE}",
        version::Long
    )?;
    write!(writer, "; https://github.com/meew0/samaku{NEWLINE}")?;
    write!(writer, "ScriptType: v4.00+{NEWLINE}")?;

    write!(
        writer,
        "WrapStyle: {}{NEWLINE}",
        script_info.wrap_style as i32
    )?;
    write!(
        writer,
        "ScaledBorderAndShadow: {}{NEWLINE}",
        yes_or_no(script_info.scaled_border_and_shadow)
    )?;
    write!(
        writer,
        "Kerning: {}{NEWLINE}",
        yes_or_no(script_info.kerning)
    )?;
    write!(writer, "Timer: {}{NEWLINE}", script_info.timer)?;
    write!(
        writer,
        "YCbCr Matrix: {}{NEWLINE}",
        ycbcr_matrix_name(script_info.ycbcr_matrix)
    )?;
    write!(
        writer,
        "PlayResX: {}{NEWLINE}",
        script_info.playback_resolution.x
    )?;
    write!(
        writer,
        "PlayResY: {}{NEWLINE}",
        script_info.playback_resolution.y
    )?;

    emit_kvs(writer, &script_info.extra_info)?;
    write!(writer, "{NEWLINE}")?;

    Ok(())
}

fn emit_aegi_metadata<W: Write>(
    writer: &mut W,
    aegi_metadata: &HashMap<String, String>,
) -> Result<(), Error> {
    if aegi_metadata.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Project Garbage]{NEWLINE}")?;
    emit_kvs(writer, aegi_metadata)?;
    write!(writer, "{NEWLINE}")
}

#[allow(clippy::similar_names)] // For scale_x/y_percent. Apparently it is not possible to allow this for an individual binding
fn emit_styles<W: Write>(writer: &mut W, styles: &[Style]) -> Result<(), Error> {
    // Ensure there is always at least one style to write
    let styles = if styles.is_empty() {
        Cow::Owned(vec![Style::default()])
    } else {
        Cow::Borrowed(styles)
    };

    write!(writer, "[V4+ Styles]{NEWLINE}")?;
    write!(writer, "{STYLE_FORMAT}{NEWLINE}")?;

    for style in &*styles {
        let safe_name = style.name.replace(',', ";");
        let safe_font_name = style.font_name.replace(',', ";");

        write!(
            writer,
            "Style: {safe_name},{safe_font_name},{},",
            style.font_size
        )?;

        emit_colour_and_transparency_to_packed(
            writer,
            style.primary_colour,
            style.primary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.secondary_colour,
            style.secondary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.border_colour,
            style.border_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.shadow_colour,
            style.shadow_transparency,
        )?;

        let bold = negative_bool(style.bold);
        let italic = negative_bool(style.italic);
        let underline = negative_bool(style.underline);
        let strike_out = negative_bool(style.strike_out);
        let scale_x_percent = style.scale.x * 100.0;
        let scale_y_percent = style.scale.y * 100.0;

        write!(
            writer,
            ",{bold},{italic},{underline},{strike_out},{scale_x_percent},{scale_y_percent},"
        )?;

        write!(
            writer,
            "{},{},{},{},{},{},{},{},{},{}{NEWLINE}",
            style.spacing,
            style.angle.0,
            style.border_style as i32,
            style.border_width,
            style.shadow_distance,
            style.alignment.as_an(),
            style.margins.left,
            style.margins.right,
            style.margins.vertical,
            style.encoding.0
        )?;
    }

    write!(writer, "{NEWLINE}")
}

fn emit_attachments<W: Write>(
    writer: &mut W,
    section_name: &str,
    filename_key: &str,
    attachments: &[Attachment],
    type_filter: AttachmentType,
) -> Result<(), Error> {
    let mut header_written = false;

    for attachment in attachments {
        if attachment.attachment_type == type_filter {
            if !header_written {
                write!(writer, "[{section_name}]{NEWLINE}")?;
                header_written = true;
            }

            write!(writer, "{filename_key}: {}{NEWLINE}", attachment.filename)?;
            let mut slice = attachment.uu_data.as_str();

            while !slice.is_empty() {
                let split_point = slice.len().min(80);
                let (to_write, new_slice) = slice.split_at(split_point);
                write!(writer, "{to_write}{NEWLINE}")?;
                slice = new_slice;
            }
        }
    }

    if header_written {
        write!(writer, "{NEWLINE}")?;
    }

    Ok(())
}

fn emit_events<W: Write>(writer: &mut W, slines: &[Sline], styles: &[Style]) -> Result<(), Error> {
    if slines.is_empty() {
        return Ok(());
    }

    write!(writer, "[Events]{NEWLINE}")?;
    write!(writer, "{EVENT_FORMAT}{NEWLINE}")?;

    for sline in slines {
        write!(
            writer,
            "{}: {},",
            event_type_name(sline.event_type),
            sline.layer_index,
        )?;
        emit_timecode(writer, sline.start.0)?;
        write!(writer, ",")?;
        emit_timecode(writer, sline.end().0)?;
        write!(writer, ",")?;
        emit_aegi_inline_string(
            writer,
            &styles[usize::try_from(sline.style_index).unwrap()].name,
        )?;
        write!(writer, ",")?;
        emit_aegi_inline_string(writer, &sline.actor)?;
        write!(
            writer,
            ",{},{},{},",
            sline.margins.left, sline.margins.right, sline.margins.vertical
        )?;
        emit_aegi_inline_string(writer, &sline.effect)?;
        write!(writer, ",")?;

        // Write extradata ID block
        if !sline.extradata_ids.is_empty() {
            write!(writer, "{{")?;
            for extradata_id in &sline.extradata_ids {
                write!(writer, "={}", extradata_id.0)?;
            }
            write!(writer, "}}")?;
        }

        // Skip newlines in sline text, should they exist
        for char in sline.text.chars() {
            match char {
                '\r' | '\n' => {}
                other => write!(writer, "{other}")?,
            }
        }
        write!(writer, "{NEWLINE}")?;
    }

    write!(writer, "{NEWLINE}")
}

fn emit_extradata<W: Write>(writer: &mut W, extradata: &Extradata) -> Result<(), Error> {
    if extradata.entries.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Extradata]{NEWLINE}")?;

    for (id, entry) in &extradata.entries {
        write!(writer, "Data: {},", id.0)?;

        match entry {
            ExtradataEntry::NdeFilter(filter) => {
                let serialised = match serialise_nde_filter(filter) {
                    Ok(serialised) => serialised,
                    Err(err) => {
                        println!("Error in NDE filter serialisation: {err}");
                        println!("NDE filter in question: {filter:?}");
                        return Err(Error);
                    }
                };

                write!(writer, "_samaku_nde_filter,e1{serialised}")?;
            }
            ExtradataEntry::Opaque { key, value } => {
                emit_aegi_inline_string(writer, key)?;

                // TODO: uuencode data unsuitable for inline encoding
                write!(writer, ",e")?;
                emit_aegi_inline_string(writer, value)?;
            }
        }

        write!(writer, "{NEWLINE}")?;
    }

    write!(writer, "{NEWLINE}")
}

const COMPRESSION_LEVEL: u8 = 6;

fn serialise_nde_filter(filter: &nde::Filter) -> Result<String, String> {
    let mut data: Vec<u8> = vec![];
    ciborium::into_writer(&filter, &mut data).map_err(|err| err.to_string())?;

    Ok(data_encoding::BASE64.encode(
        miniz_oxide::deflate::compress_to_vec(data.as_slice(), COMPRESSION_LEVEL).as_slice(),
    ))
}

fn emit_kvs<W: Write>(writer: &mut W, kvs: &HashMap<String, String>) -> Result<(), Error> {
    for (key, value) in kvs {
        write!(writer, "{key}: {value}{NEWLINE}")?;
    }

    Ok(())
}

fn emit_colour_and_transparency_to_packed<W: Write>(
    writer: &mut W,
    colour: Colour,
    transparency: Transparency,
) -> Result<(), Error> {
    write!(
        writer,
        "&H{:02X}{:02X}{:02X}{:02X}",
        transparency.0, colour.blue, colour.green, colour.red
    )
}

fn emit_timecode<W: Write>(writer: &mut W, time: i64) -> Result<(), Error> {
    let pos = time.max(0); // avoid negative numbers

    let hours = pos / 3_600_000;
    let minutes = (pos % 3_600_000) / 60_000;
    let seconds = (pos % 60_000) / 1000;
    let centiseconds = (pos % 1000) / 10;

    write!(
        writer,
        "{hours:02}:{minutes:02}:{seconds:02}.{centiseconds:02}"
    )
}

fn emit_aegi_inline_string<W: Write>(writer: &mut W, str: &str) -> Result<(), Error> {
    for char in str.chars() {
        match char {
            '\x00'..='\x1F' | '\x23' | '\x2C' | '\x3A' | '\x7C' => {
                write!(writer, "#{:02X}", char as u8)?;
            }
            _ => {
                writer.write_char(char)?;
            }
        }
    }

    Ok(())
}

fn yes_or_no(value: bool) -> &'static str {
    if value {
        "yes"
    } else {
        "no"
    }
}

// Why do ass files use -1 for true???
fn negative_bool(value: bool) -> &'static str {
    if value {
        "-1"
    } else {
        "0"
    }
}

fn ycbcr_matrix_name(matrix: YCbCrMatrix) -> &'static str {
    use YCbCrMatrix::*;

    match matrix {
        // Aegisub does not seem to ever represent “Default” or “Unknown” values as strings,
        // so just treating them like “None”.
        Default | Unknown | None => "None",
        Bt601Tv => "TV.601",
        Bt601Pc => "PC.601",
        Bt709Tv => "TV.709",
        Bt709Pc => "PC.709",
        Smtpe240MTv => "TV.240M",
        Smtpe240MPc => "PC.240M",
        FccTv => "TV.FCC",
        FccPc => "PC.FCC",
    }
}

fn event_type_name(event_type: EventType) -> &'static str {
    use EventType::*;

    match event_type {
        Dialogue => "Dialogue",
        Comment => "Comment",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn inline_encode() -> Result<(), Error> {
        let mut string = String::new();

        emit_aegi_inline_string(&mut string, "\x00\x1F\x20abc\x23defä")?;
        assert_eq!(string, "#00#1F\x20abc#23defä");

        Ok(())
    }
}
