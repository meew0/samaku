use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Error, Write};

use crate::nde::tags::{Colour, Transparency};
use crate::{config, project, version};

use super::{
    Attachment, AttachmentType, Event, EventType, Extradata, ExtradataEntry, File, ScriptInfo,
    Style, YCbCrMatrix,
};

const NEWLINE: &str = "\n";
const STYLE_FORMAT: &str = "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding";
const EVENT_FORMAT: &str =
    "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text";

/// Write the given ASS file data as an .ass file to the given writer.
///
/// Optionally, a compile context can be specified. If this is done, the file will be written as if
/// exporting for final distribution: events with NDE filters will be compiled, and samaku- and
/// Aegisub-specific metadata will be removed. Otherwise, all data will be exported verbatim, such
/// that it can be loaded again losslessly using [`File::parse`] or in Aegisub.
///
/// # Errors
/// Errors when the writer cannot be written to, or when there is an unexpected format error.
pub fn emit<W: Write>(
    writer: &mut W,
    subtitles: &File,
    compile_context: Option<super::compile::Context>,
) -> Result<(), Error> {
    emit_script_info(writer, &subtitles.script_info)?;

    if compile_context.is_none() {
        emit_aegi_metadata(writer, &subtitles.aegi_metadata)?;
    }

    emit_styles(writer, subtitles.styles.as_slice())?;
    emit_attachments(
        writer,
        "Graphics",
        "filename",
        &subtitles.attachments,
        AttachmentType::Graphic,
    )?;
    emit_attachments(
        writer,
        "Fonts",
        "fontname",
        &subtitles.attachments,
        AttachmentType::Font,
    )?;

    if let Some(context) = compile_context {
        // Compile events
        let compiled = subtitles
            .events
            .compile(&subtitles.extradata, &context, 0, None);
        emit_events(writer, &compiled, subtitles.styles.as_slice())?;
    } else {
        // Export events verbatim
        emit_events(writer, &subtitles.events, subtitles.styles.as_slice())?;
        emit_extradata(writer, &subtitles.extradata)?;
        emit_other_sections(writer, &subtitles.other_sections)?;
    }

    Ok(())
}

fn emit_script_info<W: Write>(writer: &mut W, script_info: &ScriptInfo) -> Result<(), Error> {
    write!(writer, "[Script Info]{NEWLINE}")?;
    write!(
        writer,
        "; Script generated by samaku {}{NEWLINE}",
        version::Long
    )?;
    write!(writer, "; https://github.com/meew0/samaku{NEWLINE}")?;
    write!(writer, "ScriptType: v4.00+{NEWLINE}")?;

    write!(
        writer,
        "WrapStyle: {}{NEWLINE}",
        script_info.wrap_style as i32
    )?;
    write!(
        writer,
        "ScaledBorderAndShadow: {}{NEWLINE}",
        yes_or_no(script_info.scaled_border_and_shadow)
    )?;
    write!(
        writer,
        "Kerning: {}{NEWLINE}",
        yes_or_no(script_info.kerning)
    )?;
    write!(writer, "Timer: {}{NEWLINE}", script_info.timer)?;
    write!(
        writer,
        "YCbCr Matrix: {}{NEWLINE}",
        ycbcr_matrix_name(script_info.ycbcr_matrix)
    )?;
    write!(
        writer,
        "PlayResX: {}{NEWLINE}",
        script_info.playback_resolution.x
    )?;
    write!(
        writer,
        "PlayResY: {}{NEWLINE}",
        script_info.playback_resolution.y
    )?;

    emit_kvs(writer, &script_info.extra_info)?;
    write!(writer, "{NEWLINE}")?;

    Ok(())
}

fn emit_aegi_metadata<W: Write>(
    writer: &mut W,
    aegi_metadata: &HashMap<String, String>,
) -> Result<(), Error> {
    if aegi_metadata.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Project Garbage]{NEWLINE}")?;
    emit_kvs(writer, aegi_metadata)?;
    write!(writer, "{NEWLINE}")
}

#[expect(clippy::similar_names, reason = "For scale_x/y_percent")]
fn emit_styles<W: Write>(writer: &mut W, styles: &[Style]) -> Result<(), Error> {
    // Ensure there is always at least one style to write
    let styles = if styles.is_empty() {
        Cow::Owned(vec![Style::default()])
    } else {
        Cow::Borrowed(styles)
    };

    write!(writer, "[V4+ Styles]{NEWLINE}")?;
    write!(writer, "{STYLE_FORMAT}{NEWLINE}")?;

    for style in &*styles {
        let safe_name = style.name.replace(',', ";");
        let safe_font_name = style.font_name.replace(',', ";");

        write!(
            writer,
            "Style: {safe_name},{safe_font_name},{},",
            style.font_size
        )?;

        emit_colour_and_transparency_to_packed(
            writer,
            style.primary_colour,
            style.primary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.secondary_colour,
            style.secondary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.border_colour,
            style.border_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.shadow_colour,
            style.shadow_transparency,
        )?;

        let bold = negative_bool(style.bold);
        let italic = negative_bool(style.italic);
        let underline = negative_bool(style.underline);
        let strike_out = negative_bool(style.strike_out);
        let scale_x_percent = style.scale.x * 100.0;
        let scale_y_percent = style.scale.y * 100.0;

        write!(
            writer,
            ",{bold},{italic},{underline},{strike_out},{scale_x_percent},{scale_y_percent},"
        )?;

        write!(
            writer,
            "{},{},{},{},{},{},{},{},{},{}{NEWLINE}",
            style.spacing,
            style.angle.0,
            style.border_style as i32,
            style.border_width,
            style.shadow_distance,
            style.alignment.as_an(),
            style.margins.left,
            style.margins.right,
            style.margins.vertical,
            style.encoding.0
        )?;
    }

    write!(writer, "{NEWLINE}")
}

fn emit_attachments<W: Write>(
    writer: &mut W,
    section_name: &str,
    filename_key: &str,
    attachments: &[Attachment],
    type_filter: AttachmentType,
) -> Result<(), Error> {
    let mut header_written = false;

    for attachment in attachments {
        if attachment.attachment_type == type_filter {
            if !header_written {
                write!(writer, "[{section_name}]{NEWLINE}")?;
                header_written = true;
            }

            write!(writer, "{filename_key}: {}{NEWLINE}", attachment.filename)?;
            let mut slice = attachment.uu_data.as_str();

            while !slice.is_empty() {
                let split_point = slice.len().min(80);
                let (to_write, new_slice) = slice.split_at(split_point);
                write!(writer, "{to_write}{NEWLINE}")?;
                slice = new_slice;
            }
        }
    }

    if header_written {
        write!(writer, "{NEWLINE}")?;
    }

    Ok(())
}

fn emit_events<'a, 'b, W: Write>(
    writer: &mut W,
    events: impl IntoIterator<Item = &'a Event<'b>>,
    styles: &[Style],
) -> Result<(), Error>
where
    'b: 'a,
{
    let mut header_written = false;

    for event in events {
        if !header_written {
            write!(writer, "[Events]{NEWLINE}")?;
            write!(writer, "{EVENT_FORMAT}{NEWLINE}")?;
            header_written = true;
        }

        write!(
            writer,
            "{}: {},",
            event_type_name(event.event_type),
            event.layer_index,
        )?;
        emit_timecode(writer, event.start.0)?;
        write!(writer, ",")?;
        emit_timecode(writer, event.end().0)?;
        write!(writer, ",")?;
        emit_aegi_inline_string(writer, &styles[event.style_index].name)?;
        write!(writer, ",")?;
        emit_aegi_inline_string(writer, &event.actor)?;
        write!(
            writer,
            ",{},{},{},",
            event.margins.left, event.margins.right, event.margins.vertical
        )?;
        emit_aegi_inline_string(writer, &event.effect)?;
        write!(writer, ",")?;

        // Write extradata ID block
        if !event.extradata_ids.is_empty() {
            write!(writer, "{{")?;
            for extradata_id in &event.extradata_ids {
                write!(writer, "={}", extradata_id.0)?;
            }
            write!(writer, "}}")?;
        }

        // Skip newlines in event text, should they exist
        for char in event.text.chars() {
            match char {
                '\r' | '\n' => {}
                other => write!(writer, "{other}")?,
            }
        }
        write!(writer, "{NEWLINE}")?;
    }

    if header_written {
        write!(writer, "{NEWLINE}")
    } else {
        Ok(())
    }
}

fn emit_extradata<W: Write>(writer: &mut W, extradata: &Extradata) -> Result<(), Error> {
    if extradata.entries.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Extradata]{NEWLINE}")?;

    for (id, entry) in &extradata.entries {
        write!(writer, "Data: {},", id.0)?;

        match entry {
            ExtradataEntry::NdeFilter(filter) => {
                let serialised =
                    match project::serialize_czb(filter, config::NDE_FILTER_COMPRESSION_LEVEL) {
                        Ok(serialised) => serialised,
                        Err(err) => {
                            println!("Error in NDE filter serialisation: {err}");
                            println!("NDE filter in question: {filter:?}");
                            return Err(Error);
                        }
                    };

                write!(writer, "_samaku_nde_filter,e1{serialised}")?;
            }
            ExtradataEntry::Opaque { key, value } => {
                emit_aegi_inline_string(writer, key)?;

                // The value can be specified using inline or UU encoding. Aegisub uses inline
                // encoding by default, but switches to UU encoding if it would be shorter.
                // If the input data is not valid UTF-8, the inline encoded result will not be,
                // either; Aegisub does not care about this but we do.
                if let Some(inline_encoded) = try_inline_encode(value) {
                    write!(writer, ",e{inline_encoded}")?;
                } else {
                    // Fall back to UU encoding
                    let uu_encoded = super::uu::encode(value);
                    write!(writer, ",u{uu_encoded}")?;
                }
            }
        }

        write!(writer, "{NEWLINE}")?;
    }

    write!(writer, "{NEWLINE}")
}

fn emit_other_sections<W: Write>(
    writer: &mut W,
    other_sections: &HashMap<String, Vec<String>>,
) -> Result<(), Error> {
    for (header, lines) in other_sections {
        write!(writer, "[{header}]{NEWLINE}")?;
        for line in lines {
            write!(writer, "{line}{NEWLINE}")?;
        }
        write!(writer, "{NEWLINE}")?;
    }

    Ok(())
}

/// Try to inline encode some arbitrary binary data. Returns `Some(_)` if both the conversion
/// succeeded and the inline encoded data would be shorter than the equivalent UU-encoded data.
fn try_inline_encode(data: &[u8]) -> Option<String> {
    if let Ok(utf8_str) = std::str::from_utf8(data) {
        let mut inline_encoded = String::new();
        if emit_aegi_inline_string(&mut inline_encoded, utf8_str).is_err() {
            return None;
        }

        if 4 * data.len() >= 3 * inline_encoded.len() {
            return Some(inline_encoded);
        }
    }

    None
}

fn emit_kvs<W: Write>(writer: &mut W, kvs: &HashMap<String, String>) -> Result<(), Error> {
    for (key, value) in kvs {
        write!(writer, "{key}: {value}{NEWLINE}")?;
    }

    Ok(())
}

fn emit_colour_and_transparency_to_packed<W: Write>(
    writer: &mut W,
    colour: Colour,
    transparency: Transparency,
) -> Result<(), Error> {
    write!(
        writer,
        "&H{:02X}{:02X}{:02X}{:02X}",
        transparency.0, colour.blue, colour.green, colour.red
    )
}

fn emit_timecode<W: Write>(writer: &mut W, time: i64) -> Result<(), Error> {
    let pos = time.max(0); // avoid negative numbers

    let hours = pos / 3_600_000;
    let minutes = (pos % 3_600_000) / 60_000;
    let seconds = (pos % 60_000) / 1000;
    let centiseconds = (pos % 1000) / 10;

    write!(
        writer,
        "{hours}:{minutes:02}:{seconds:02}.{centiseconds:02}"
    )
}

fn emit_aegi_inline_string<W: Write>(writer: &mut W, str: &str) -> Result<(), Error> {
    for char in str.chars() {
        match char {
            '\x00'..='\x1F' | '\x23' | '\x2C' | '\x3A' | '\x7C' => {
                write!(writer, "#{:02X}", char as u8)?;
            }
            _ => {
                writer.write_char(char)?;
            }
        }
    }

    Ok(())
}

fn yes_or_no(value: bool) -> &'static str {
    if value { "yes" } else { "no" }
}

// Why do ass files use -1 for true???
fn negative_bool(value: bool) -> &'static str {
    if value { "-1" } else { "0" }
}

fn ycbcr_matrix_name(matrix: YCbCrMatrix) -> &'static str {
    use YCbCrMatrix::*;

    match matrix {
        // Aegisub does not seem to ever represent “Default” or “Unknown” values as strings,
        // so just treating them like “None”.
        Default | Unknown | None => "None",
        Bt601Tv => "TV.601",
        Bt601Pc => "PC.601",
        Bt709Tv => "TV.709",
        Bt709Pc => "PC.709",
        Smtpe240MTv => "TV.240M",
        Smtpe240MPc => "PC.240M",
        FccTv => "TV.FCC",
        FccPc => "PC.FCC",
    }
}

fn event_type_name(event_type: EventType) -> &'static str {
    use EventType::*;

    match event_type {
        Dialogue => "Dialogue",
        Comment => "Comment",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn inline_encode() -> Result<(), Error> {
        let mut string = String::new();

        emit_aegi_inline_string(&mut string, "\x00\x1F\x20abc\x23defä")?;
        assert_eq!(string, "#00#1F\x20abc#23defä");

        Ok(())
    }
}
