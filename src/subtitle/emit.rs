use std::collections::HashMap;
use std::fmt::{Error, Write};

use crate::version;

use super::{ScriptInfo, SideData, SlineTrack, YCbCrMatrix};

const NEWLINE: &str = "\n";

/// Write the given ASS file data as an .ass file to the given writer.
///
/// # Errors
/// Errors when the writer cannot be written to, or when there is an unexpected format error.
pub fn emit<W: Write>(
    writer: &mut W,
    script_info: &ScriptInfo,
    subtitles: &SlineTrack,
    side_data: &SideData,
) -> Result<(), Error> {
    emit_script_info(writer, script_info)?;
    emit_aegi_metadata(writer, &side_data.aegi_metadata)?;

    Ok(())
}

fn emit_script_info<W: Write>(writer: &mut W, script_info: &ScriptInfo) -> Result<(), Error> {
    write!(writer, "[Script Info]{NEWLINE}")?;
    write!(
        writer,
        "; Script generated by samaku {}{NEWLINE}",
        version::Long
    )?;
    write!(writer, "; https://github.com/meew0/samaku{NEWLINE}")?;
    write!(writer, "ScriptType: v4.00+{NEWLINE}")?;

    write!(
        writer,
        "WrapStyle: {}{NEWLINE}",
        script_info.wrap_style as i32
    )?;
    write!(
        writer,
        "ScaledBorderAndShadow: {}{NEWLINE}",
        yes_or_no(script_info.scaled_border_and_shadow)
    )?;
    write!(
        writer,
        "Kerning: {}{NEWLINE}",
        yes_or_no(script_info.kerning)
    )?;
    write!(writer, "Timer: {}{NEWLINE}", script_info.timer)?;
    write!(
        writer,
        "YCbCr Matrix: {}{NEWLINE}",
        ycbcr_matrix_name(script_info.ycbcr_matrix)
    )?;
    write!(
        writer,
        "PlayResX: {}{NEWLINE}",
        script_info.playback_resolution.x
    )?;
    write!(
        writer,
        "PlayResY: {}{NEWLINE}",
        script_info.playback_resolution.y
    )?;

    emit_kvs(writer, &script_info.extra_info)?;
    write!(writer, "{NEWLINE}")?;

    Ok(())
}

fn emit_aegi_metadata<W: Write>(
    writer: &mut W,
    aegi_metadata: &HashMap<String, String>,
) -> Result<(), Error> {
    if aegi_metadata.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Project Garbage]{NEWLINE}")?;
    emit_kvs(writer, aegi_metadata)?;
    write!(writer, "{NEWLINE}")
}

fn emit_kvs<W: Write>(writer: &mut W, kvs: &HashMap<String, String>) -> Result<(), Error> {
    for (key, value) in kvs {
        write!(writer, "{key}: {value}{NEWLINE}")?;
    }

    Ok(())
}

fn yes_or_no(value: bool) -> &'static str {
    if value {
        "yes"
    } else {
        "no"
    }
}

fn ycbcr_matrix_name(matrix: YCbCrMatrix) -> &'static str {
    use YCbCrMatrix::*;

    match matrix {
        // Aegisub does not seem to ever represent “Default” or “Unknown” values as strings,
        // so just treating them like “None”.
        Default | Unknown | None => "None",
        Bt601Tv => "TV.601",
        Bt601Pc => "PC.601",
        Bt709Tv => "TV.709",
        Bt709Pc => "PC.709",
        Smtpe240MTv => "TV.240M",
        Smtpe240MPc => "PC.240M",
        FccTv => "TV.FCC",
        FccPc => "PC.FCC",
    }
}
