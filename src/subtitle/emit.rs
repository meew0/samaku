use std::borrow::Cow;
use std::collections::HashMap;
use std::fmt::{Error, Write};

use crate::nde::tags::{Colour, Transparency};
use crate::version;

use super::{ScriptInfo, SideData, SlineTrack, Style, YCbCrMatrix};

const NEWLINE: &str = "\n";
const STYLE_FORMAT: &str = "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding";
const EVENT_FORMAT: &str =
    "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text";

/// Write the given ASS file data as an .ass file to the given writer.
///
/// # Errors
/// Errors when the writer cannot be written to, or when there is an unexpected format error.
pub fn emit<W: Write>(
    writer: &mut W,
    script_info: &ScriptInfo,
    subtitles: &SlineTrack,
    side_data: &SideData,
) -> Result<(), Error> {
    emit_script_info(writer, script_info)?;
    emit_aegi_metadata(writer, &side_data.aegi_metadata)?;
    emit_styles(writer, &subtitles.styles)?;

    Ok(())
}

fn emit_script_info<W: Write>(writer: &mut W, script_info: &ScriptInfo) -> Result<(), Error> {
    write!(writer, "[Script Info]{NEWLINE}")?;
    write!(
        writer,
        "; Script generated by samaku {}{NEWLINE}",
        version::Long
    )?;
    write!(writer, "; https://github.com/meew0/samaku{NEWLINE}")?;
    write!(writer, "ScriptType: v4.00+{NEWLINE}")?;

    write!(
        writer,
        "WrapStyle: {}{NEWLINE}",
        script_info.wrap_style as i32
    )?;
    write!(
        writer,
        "ScaledBorderAndShadow: {}{NEWLINE}",
        yes_or_no(script_info.scaled_border_and_shadow)
    )?;
    write!(
        writer,
        "Kerning: {}{NEWLINE}",
        yes_or_no(script_info.kerning)
    )?;
    write!(writer, "Timer: {}{NEWLINE}", script_info.timer)?;
    write!(
        writer,
        "YCbCr Matrix: {}{NEWLINE}",
        ycbcr_matrix_name(script_info.ycbcr_matrix)
    )?;
    write!(
        writer,
        "PlayResX: {}{NEWLINE}",
        script_info.playback_resolution.x
    )?;
    write!(
        writer,
        "PlayResY: {}{NEWLINE}",
        script_info.playback_resolution.y
    )?;

    emit_kvs(writer, &script_info.extra_info)?;
    write!(writer, "{NEWLINE}")?;

    Ok(())
}

fn emit_aegi_metadata<W: Write>(
    writer: &mut W,
    aegi_metadata: &HashMap<String, String>,
) -> Result<(), Error> {
    if aegi_metadata.is_empty() {
        return Ok(());
    }

    write!(writer, "[Aegisub Project Garbage]{NEWLINE}")?;
    emit_kvs(writer, aegi_metadata)?;
    write!(writer, "{NEWLINE}")
}

#[allow(clippy::similar_names)] // For scale_x/y_percent. Apparently it is not possible to allow this for an individual binding
fn emit_styles<W: Write>(writer: &mut W, styles: &[Style]) -> Result<(), Error> {
    // Ensure there is always at least one style to write
    let styles = if styles.is_empty() {
        Cow::Owned(vec![Style::default()])
    } else {
        Cow::Borrowed(styles)
    };

    write!(writer, "[V4+ Styles]{NEWLINE}")?;
    write!(writer, "{STYLE_FORMAT}{NEWLINE}")?;

    for style in &*styles {
        let safe_name = style.name.replace(',', ";");
        let safe_font_name = style.font_name.replace(',', ";");

        write!(
            writer,
            "Style: {safe_name},{safe_font_name},{},",
            style.font_size
        )?;

        emit_colour_and_transparency_to_packed(
            writer,
            style.primary_colour,
            style.primary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.secondary_colour,
            style.secondary_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.border_colour,
            style.border_transparency,
        )?;
        write!(writer, ",")?;
        emit_colour_and_transparency_to_packed(
            writer,
            style.shadow_colour,
            style.shadow_transparency,
        )?;

        let bold = negative_bool(style.bold);
        let italic = negative_bool(style.italic);
        let underline = negative_bool(style.underline);
        let strike_out = negative_bool(style.strike_out);
        let scale_x_percent = style.scale.x * 100.0;
        let scale_y_percent = style.scale.y * 100.0;

        write!(
            writer,
            ",{bold},{italic},{underline},{strike_out},{scale_x_percent},{scale_y_percent},"
        )?;

        write!(
            writer,
            "{},{},{},{},{},{},{},{},{},{}{NEWLINE}",
            style.spacing,
            style.angle.0,
            style.border_style as i32,
            style.border_width,
            style.shadow_distance,
            style.alignment.as_an(),
            style.margins.left,
            style.margins.right,
            style.margins.vertical,
            style.encoding.0
        )?;
    }

    write!(writer, "{NEWLINE}")
}

fn emit_kvs<W: Write>(writer: &mut W, kvs: &HashMap<String, String>) -> Result<(), Error> {
    for (key, value) in kvs {
        write!(writer, "{key}: {value}{NEWLINE}")?;
    }

    Ok(())
}

fn emit_colour_and_transparency_to_packed<W: Write>(
    writer: &mut W,
    colour: Colour,
    transparency: Transparency,
) -> Result<(), Error> {
    write!(
        writer,
        "&H{:02X}{:02X}{:02X}{:02X}",
        transparency.0, colour.blue, colour.green, colour.red
    )
}

fn yes_or_no(value: bool) -> &'static str {
    if value {
        "yes"
    } else {
        "no"
    }
}

// Why do ass files use -1 for true???
fn negative_bool(value: bool) -> &'static str {
    if value {
        "-1"
    } else {
        "0"
    }
}

fn ycbcr_matrix_name(matrix: YCbCrMatrix) -> &'static str {
    use YCbCrMatrix::*;

    match matrix {
        // Aegisub does not seem to ever represent “Default” or “Unknown” values as strings,
        // so just treating them like “None”.
        Default | Unknown | None => "None",
        Bt601Tv => "TV.601",
        Bt601Pc => "PC.601",
        Bt709Tv => "TV.709",
        Bt709Pc => "PC.709",
        Smtpe240MTv => "TV.240M",
        Smtpe240MPc => "PC.240M",
        FccTv => "TV.FCC",
        FccPc => "PC.FCC",
    }
}
